# Apache Server
Apache is a popular open-source HTTP web server software that is widely used to host and serve dynamic websites and web applications. It is capable of handling multiple concurrent connections and can handle large amounts of traffic efficiently.
<br/>

To use Apache, you would typically install the Apache software on a server machine, configure the server to serve content, and then host your web application or website on the server. The server would then listen for incoming HTTP requests from clients and return the appropriate response, such as a web page, an image, or data from a database.
<br/>

Here are the steps to use Apache:

- Install Apache on your server machine. This can be done using the package manager of your operating system, such as apt on Ubuntu or yum on CentOS.

- Configure the Apache server. You'll need to set the server's document root, configure the port number that Apache listens on, and define any virtual hosts or other configuration options you need.

- Host your website or web application on the Apache server. This can be done by placing the files for your website or application in the document root directory that you defined in the Apache configuration.

- Start the Apache server and test it by making HTTP requests to it from a client machine.

Once you've completed these steps, your Apache server will be serving content to clients. You can use tools like Apache's log files to monitor traffic and track any errors or issues that may arise.

# Django Development Server
The Django development server is a lightweight, built-in web server that is included with the Django web framework. It is intended for use during the development of Django applications, and it allows developers to quickly test their applications without the need for a full-fledged web server setup.

The development server is designed to be easy to use, and it can be started from the command line with a single command. When started, it listens on a specific port for incoming HTTP requests and then dispatches those requests to the appropriate Django view function for processing. The response generated by the view function is then sent back to the client as an HTTP response.

Some key benefits of using the Django development server include:

- Simplicity: The development server is easy to use and does not require any additional setup or configuration.

- Convenience: You can start the development server and begin testing your application with a single command.

- Speed: The development server is lightweight and optimized for fast performance, making it ideal for quickly testing and iterating on your application during development.

While the Django development server is great for development, it is not intended for use in a production environment. For production deployment, you should use a more robust and scalable web server, such as Apache or Nginx.

# path() arguments 
The `path()` function is passed four arguments, two required: **route and view**, and two optional: **kwargs, and name**. At this point, it’s worth reviewing what these arguments are for.

- **route:**
route is a string that contains a URL pattern. When processing a request, Django starts at the first pattern in urlpatterns and makes its way down the list, comparing the requested URL against each pattern until it finds one that matches.
Patterns don’t search GET and POST parameters, or the domain name. For example, in a request to https://www.example.com/myapp/, the URLconf will look for `myapp/`. In a request to https://www.example.com/myapp/?page=3, the URLconf will also look for `myapp/`.


- **view:**
When Django finds a matching pattern, it calls the specified view function with an HttpRequest object as the first argument and any “captured” values from the route as keyword arguments. We’ll give an example of this in a bit.


- **kwargs:**
Arbitrary keyword arguments can be passed in a dictionary to the target view. We aren’t going to use this feature of Django in the tutorial.


- **name:**
Naming your URL lets you refer to it unambiguously from elsewhere in Django, especially from within templates. This powerful feature allows you to make global changes to the URL patterns of your project while only touching a single file.

# Database Setup
Now, open up `mysite/settings.py`. It’s a normal Python module with module-level variables representing Django settings.
By default, the configuration uses SQLite. If you’re new to databases, or you’re just interested in trying Django, this is the easiest choice. SQLite is included in Python, so you won’t need to install anything else to support your database.

If you wish to use another database, install the appropriate database bindings and change the following keys in the DATABASES 'default' item to match your database connection settings:

- _ENGINE_ – Either `'django.db.backends.sqlite3'`, `'django.db.backends.postgresql'`, `'django.db.backends.mysql'`, or `'django.db.backends.oracle'`. Other backends are also available.
- _NAME_ – The name of your database. If you’re using SQLite, the database will be a file on your computer; in that case, NAME should be the full absolute path, including filename, of that file. The default value, `BASE_DIR / 'db.sqlite3'`, will store the file in your project directory.

# Migrate Command
## Installed Apps
By default, INSTALLED_APPS contains the following apps, all of which come with Django:

- django.contrib.admin – The admin site. You’ll use it shortly.
- django.contrib.auth – An authentication system.
- django.contrib.contenttypes – A framework for content types.
- django.contrib.sessions – A session framework.
- django.contrib.messages – A messaging framework.
- django.contrib.staticfiles – A framework for managing static files.

These applications are included by default as a convenience for the common case.

Some of these applications make use of at least one database table, though, so we need to create the tables in the database before we can use them. To do that, run the following command:
`py manage.py migrate`

### Migrate 
The **migrate** command looks at the `INSTALLED_APPS` setting and creates any necessary database tables according to the database settings in your `mysite/settings.py` file and the database migrations shipped with the app. You’ll see a message for each migration it applies. If you’re interested, run the command-line client for your database and type `\dt` (PostgreSQL), `SHOW TABLES;` (MariaDB, MySQL), **.schema** (SQLite), or `SELECT TABLE_NAME FROM USER_TABLES`; (Oracle) to display the tables Django created.

# DRY Principle in Django
The DRY (Don't Repeat Yourself) principle is a software design principle that states that every piece of knowledge or logic in a software system should have a single, unambiguous, authoritative representation. In Django, this principle is applied through the use of reusable code and modular design, which helps to keep the codebase clean and maintainable. 

For example, common functionality, such as authentication and authorization, can be placed in a separate module and reused across multiple applications. This helps to minimize duplication of code and reduces the likelihood of bugs and inconsistencies.

In Django, the DRY principle is achieved through the use of reusable code, such as reusable templates and generic views. Additionally, the DRY principle can be achieved through the use of mixins and abstract classes, which allow you to extract common functionality into a single place.
Here's a simple example to illustrate the concept of DRY in Django:
```python
def book_view(request):
    books = Book.objects.all()
    context = {'books': books}
    return render(request, 'book_template.html', context)

def movie_view(request):
    movies = Movie.objects.all()
    context = {'movies': movies}
    return render(request, 'movie_template.html', context)

def album_view(request):
    albums = Album.objects.all()
    context = {'albums': albums}
    return render(request, 'album_template.html', context)
```

As you can see, each view is essentially doing the same thing: retrieving a list of objects, generating a context dictionary, and rendering a template. This violates the DRY principle because the same code is being repeated in each view.

To follow the DRY principle, you could refactor this code into a single, reusable function. For example:
```python
def object_view(request, model):
    objects = model.objects.all()
    context = {'objects': objects}
    return render(request, '{}_template.html'.format(model._meta.model_name), context)
```